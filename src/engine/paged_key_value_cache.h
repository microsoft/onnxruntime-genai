// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
#pragma once

#include <stdint.h>
#include <memory>
#include <vector>
#include <list>

#include "block.h"
#include "request.h"

namespace Generators {

struct PagedKeyValueCache {
 public:
  PagedKeyValueCache(std::shared_ptr<Model> model);

  bool CanAdd(std::shared_ptr<Request> request) const;

  void Add(std::shared_ptr<Request> request);

  bool CanAppendTokens(std::shared_ptr<Request> request) const;

  void AppendTokens(std::shared_ptr<Request> request);

  void Remove(std::shared_ptr<Request> request);

  // Returns the K, V cache.
  std::vector<std::pair<OrtValue*, OrtValue*>> Cache();

  std::vector<std::pair<const char*, const char*>> Names();

  std::vector<std::pair<const char*, const char*>> OutputNames();

  // Shape: [batch_size, max_num_blocks_per_sequence]
  // Assume that the block tables are requested for 3 sequences
  // Assume the block tables for given sequence / requests are:
  // {
  //   [0, 1, 2],
  //   [3, 7, 9],
  //   [4, 5, 6, 8]
  // }
  // Invoking this function will return the block tables as:
  // [ [0, 1, 2, -1],
  //   [3, 7, 9, -1],
  //   [4, 5, 6, 8] ]
  //
  // This implies that the sequence in the first request has its kv cache stored in blocks with ids [0, 1, 2],
  // the sequence in the second request has its kv cache stored in blocks with ids [3, 7, 9], and
  // the sequence in the third request has its kv cache stored in blocks with ids [4, 5, 6, 8].
  // -1 is used to pad the block tables to the max blocks per sequence from the given sequences.
  // The order of the block tables is based on the order the provided requests.
  std::pair<OrtValue*, const char*> BlockTables(const std::vector<std::shared_ptr<Request>>& requests);

  void UpdateState(State& state, const std::vector<std::shared_ptr<Request>>& requests);

 private:
  struct LayerCache {
    std::unique_ptr<OrtValue> key_cache;    // Shape: [num_blocks, block_size * num_kv_heads * head_size]
    std::unique_ptr<OrtValue> value_cache;  // Shape: [num_blocks, block_size * num_kv_heads * head_size]
    std::string key_cache_name;
    std::string value_cache_name;
    std::string key_cache_output_name;
    std::string value_cache_output_name;
  };

  //   The key and the value cache is represented as an array of blocks. Each block contains
  //   a number of slots equal to the block size. Each slot contains num_kv_heads * head_size
  //   elements. Here the slot represents data generated by the model for a single token.
  //   This key-value cache is allocated for each layer in the model.
  //   Although the cache is preallocated, the actual memory is alloted to a request only as needed.
  //   View of the cache for each layer (LayerCache):
  //         -->|size of each block = block_size(M) * size of each slot|<--
  //            |______________________________________________________|
  //            |       -->|          |<-- size of each slot = num_kv_heads * head_size
  //            |          |          |                                |
  //            |__________|__________|________________________________|
  //   block 0  |  slot 0  |  slot 1  |  slot 2  |     .    |  slot M  |
  //   block 1  |          |          |          |          |          |
  //   block 2  |          |          |          |          |          |
  //   block 3  |          |          |          |          |          |
  //      .     |          |          |          |          |          |
  //      .     |          |          |          |          |          |
  //      .     |          |          |          |          |          |
  //            |          |          |          |          |          |
  //   block N  |__________|__________|__________|__________|__________|
  //   N = num_blocks per layer
  //   M = block_size per block

  struct BlockTable {
    std::shared_ptr<Request> request;
    std::vector<std::shared_ptr<Block>> blocks;
  };

  std::shared_ptr<Model> model_;
  std::vector<LayerCache> cache_;                 // Pair of key and value caches for all layers
  std::unique_ptr<BlockPool> block_pool_;         // Allocator for blocks
  std::vector<BlockTable> block_tables_;          // Block table for all requests in the cache
  std::unique_ptr<OrtValue> block_tables_value_;  // Block tables for all requests in the cache
};

}  // namespace Generators